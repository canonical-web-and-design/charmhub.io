{% extends 'base_layout.html' %}

{% block meta_copydoc %}https://docs.google.com/document/d/1UuNVajNHcWcF9d-fSnPFl8Zi4sDl21G5K-F09F8c3i8{% endblock meta_copydoc %}

{% block meta_description %}An ‘operator’ in the Kubernetes world is a trusted container which drives other containers, simplifying the work of operations for a human administrator. Since the operator is software, it can encode best practices and it never gets tired.{% endblock %}

{% block content %}
<section class="p-strip--charmhub is-shallow is-dark">
  <div class="u-fixed-width">
    <h1 class="p-heading--2">About Open Operators Collection</h1>
  </div>
</section>
<section class="p-strip--main">
  <div class="u-fixed-width">
    <h2>What is a Kubernetes Operator?</h2>
    <p>
      An ‘operator’ in the Kubernetes world is a trusted container which drives other containers, simplifying the work of operations for a human administrator. Since the operator is software, it can encode best practices and it never gets tired. The operator is available on demand 24/7 to react to problems, and it can do the tedious work of getting all the low-level details right.
    </p>
    <p>
      In Kubernetes, there are a *lot* of low&ndash;level details. So operators are a way to manage the complexity of Kubernetes application operations by having software do the work.
    </p>
    <p>
      In this community, we are also interested in the idea of operators outside of Kubernetes. For example, using operators to deploy and run our legacy workloads on VMWare or bare metal or OpenStack, because that legacy estate is huge and having software do the work is very helpful. Even though the term ‘operator’ started in Kubernetes, we use the term here more generally to describe the class of ‘software that drives software’.
    </p>
    <h2>
      What is the Open Operator Collection?
    </h2>
    <p>
      The Open Operator Collection is an open&ndash;source initiative to provide a large number of interoperable, easily integrated operators for common workloads. A diverse community of specialists in operations and security contribute to the collection, leading the work to implement high-quality operators for these applications. The collection aims for consistency across a very wide range of operators, using a common Python Operator Framework to enable seamless integration between operators from different maintainers.
    </p>
    <p>
      Our primary focus is Kubernetes operators, because the complexity of daily operations in a sophisticated multi-cloud K8s environment lends itself to automation of this kind. However, we also accept and maintain operators for many workloads in traditional compute environments like virtualization, public cloud and bare metal.
    </p>
    <h2>What is dev&ndash;sec&ndash;ops?</h2>
    <p>
      Dev&ndash;sec&ndash;ops is the merging of product development, security, and operations. Practitioners of dev-sec-ops encourage the formation of multi&ndash;disciplinary teams that consider the operational and security aspects of enterprise software at the same time, ideally during product development itself. Instead of staying silent, or simply making recommendations about security and operations, dev-sec-ops teams aim to deliver automated solutions that cover all these elements together.
    </p>
    <p>
      Operators are dev&ndash;sec&ndash;ops because they are in effect total automation &ndash; all of the product installation, integration, operations and lifecycle management are encapsulated in the code of the operator, so all of the security and operations elements are by definition included in operator design and implementation.
    </p>
    <h2>
      What is a charm?
    </h2>
    <p>
      A charm is a software package of an operator together with metadata that supports the deployment and integration of many operators in a coherent system. An operator packaged as a charm means that it is configured, operated and integrated in a standard way regardless of the vendor or the application. Charms enable multi&ndash;vendor operator collections that have standardised behaviours, reducing the learning curve associated with each operator and supporting richer application ecosystems.
    </p>
    <h2>
      How does the Open Operator Collection handle integration?
    </h2>
    <p>
      Operators in the collection declare explicit points of integration that they support. For example, an operator can say that it can provide a MySQL database to another operator, and that it can send its logs to an rsyslog service. Those points of integration are called endpoints. The operator is then told which other operators are being integrated with each <i>endpoint</i> that it offers.
    </p>
    <h2>
      What is a charm interface?
    </h2>
    <p>
      Each endpoint on a charm has a type, called the <i>interface</i>. Operators can only be integrated with one another if they have endpoints with the same type. Endpoints are, roughly speaking, <i>directional</i>, they can be ‘inbound’ or ‘outbound’ which we call <i>requires or provides</i>. You can only integrate two endpoints if they have the same interface (type) and opposite directions - one a provider and one a requirer.
    </p>
  </div>
</section>
{% endblock %}
