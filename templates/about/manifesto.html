{% extends 'about/about_layout.html' %}

{% block meta_copydoc %}https://docs.google.com/document/d/1bPFekWN4xrUue2l8F2_2w3ygnh06VHMA3VUVoTzuAFk{% endblock meta_copydoc %}

{% block meta_description %}We lead the Open Operator Collection, on a mission to elevate the art of dev&ndash;sec&ndash;ops with open&ndash;source operators that control enterprise applications{% endblock %}

{% block about_content %}
  <h2>The Open Operator Manifesto</h2>
  <p>
    We lead the Open Operator Collection, on a mission to elevate the art of dev&ndash;sec&ndash;ops with open&ndash;source operators that control enterprise applications. These values and guidelines ensure high&ndash;quality code, conversations and experiences for our community.
  </p>
  <ol class="p-list--ordered">
    <li>
      <strong>Source Required.</strong> An operator is software that takes control of an enterprise system, application or service. The operator source code is essential to verify expected behavior. We make operator source available so that everybody can understand exactly what happens on their systems.
    </li>
    <li>
      <strong>Open source preferred.</strong> We are an open source community to enable everyone to contribute to the shared problem of common workload operations. Our frameworks and tools are open source to enable the widest benefit of our work. We know some vendors cannot use open source, so our framework license allows them to create proprietary operators while preserving interoperability.
    </li>
    <li>
      <strong>Security.</strong> Application security is critical to enterprise integrity. The most common cause of vulnerability in enterprise architecture is human error. Software operators ensure best practice for every deployment and every change. A good operator applies defense-in-depth to every aspect of workload operations &ndash; from data encryption and application confinement to password selection and key handling. We review all operators for security. We treat operator code just like application code, with Common Vulnerabilities and Exposures, and we distribute fixes fast and automatically.
    </li>
    <li>
      <strong>Substrate neutral.</strong> An operator should not assume any particular infrastructure or Kubernetes implementation, but use common, portable primitives. Where specific application capabilities can be unlocked on a particular substrate, they should be optional.
    </li>
    <li>
      <strong>Reuse.</strong> A well&dash;behaved operator is general and not deployment-specific. The operator understands many ways to deploy the application &ndash; large or small scale, resilient or minimal &ndash; and it serves the diverse needs of multiple users equally. Reusability drives correctness and completeness, it grows the community of users and contributors, and it expands the configurations, scenarios and integrations supported by the operator.
    </li>
    <li>
      <strong>Updates and Upgrades.</strong> Software evolves, and deployments must update to benefit from those improvements. High&dash;quality updates inspire the confidence to apply them frequently, which is essential for security. Good operator updates are independent of application upgrades, because application upgrades must be deliberate choices. A good operator distribution system has mechanisms to ensure smooth upgrades across application generations.
    </li>
    <li>
      <strong>Purposeful config.</strong> Application software has many configurable capabilities, but most of those exist to support higher&dash;level goals or purposes. A good operator distinguishes between purpose and mechanism, offers hig&dash;-level purposeful config, and translates that to the many low&dash;level mechanism configs of the workload.
    </li>
    <li>
      <strong>Scale.</strong> Applications are often clustered for resilience or performance. A good operator will handle scale, guided by purposeful config and the workload nature, and respond to dynamic changes. A great operator will scale up and down equally well.
    </li>
    <li>
      <strong>Actionable.</strong> Every application has a set of actions that can be performed by administrators. A good operator declares them and facilitates reliable execution. Daily actions like backup, restore, reset, and restart should never require direct admin access to underlying systems, configuration files, tools or containers. Actions should be remote procedures driven by API or CLI, subject to permissions, and logged for audit and accountability.
    </li>
    <li>
      <strong>Awareness.</strong> A good operator evaluates and presents the state of its workload in human&dash;friendly terms. The operator understands the health, availability, and dependencies of the application, assesses those and presents them to the admin. Admins should never access the underlying systems or containers to assess the state of a workload, because the operator reports it continuously and automatically.
    </li>
    <li>
      <strong>Leadership.</strong> In distributed systems, some decisions must be taken for a whole cluster. Problems occur if different units make independent conflicting decisions. An operator should always know whether to make a decision or defer to another unit. Leader decisions should be available to all units in a reliable way. Leadership in distributed systems is a hard problem, and a well&dash;formed operator will follow proven algorithms for leader election to ensure cluster consistency.
    </li>
    <li>
      <strong>Composition.</strong> It is common to integrate multiple pieces of software on the same system. For example, an intrusion detection system may need direct access to the processes on a database server. The operator framework must provide clear mechanisms to enable diverse functions to coexist in a single execution environment such as a Kubernetes pod or a machine.
    </li>
    <li>
      <strong>Topology.</strong> Most of the work of enterprise software is integration. A good operator goes beyond the application lifecycle to the application graph, understanding integration with other applications, and controlling its workload appropriately.
    </li>
    <li>
      <strong>Interoperable.</strong> Enterprises require multi&dash;vendor deployments to work well. Operators should work with operators from other vendors and publishers. Collaboration and coordination are best done in a public forum to ensure the widest perspective.
    </li>
    <li>
      <strong>Consistent.</strong> Admins work with many operators in large systems of many components. A well&dash;designed operator will reuse common patterns of naming and behavior to simplify the learning curve and increase administrator effectiveness.
    </li>
    <li>
      <strong>Substitution.</strong> Many applications provide services that are standard or similar. Enterprises expect to choose the actual implementation in a particular deployment, or swap implementations later. Operators should not assume specific integration counterparts, allowing their substitution.
    </li>
    <li>
      <strong>Model driven.</strong> All applications must all work together for a successful deployment. A change in one application is often relevant for all the applications integrated with it. Operators should observe and respond to changes in a model that describes the whole deployment application topology and configuration.
    </li>
    <li>
      <strong>Resourceful.</strong> An operator should not assume a given resource allocation or scale. A user may deploy the application on a few small machines in one scenario, and many large machines in another. The model determines resources, not the operator.
    <li>
      <strong>Network Agnostic.</strong> Different enterprises take different approaches to networking. An operator should learn what&rsquo;s intended from the model, and not hard-code specific network details. There are good reasons to separate services on different networks, and operators should support segregated network architectures.
    </li>
    <li>
      <strong>Cross platform.</strong> Enterprises have applications on a wide range of operating systems like Windows and Linux, and many deployments integrate systems on diverse platforms. The operator framework should enable multi&dash;platform scenarios.
    </li>
    <li>
      <strong>Architecture neutral.</strong> Where the underlying application provider cares to be multi&dash;arch, the operator community should care too.
    </li>
    <li>
      <strong>Tested.</strong> Operators are privileged software dealing with critical functionality in sensitive environments. A good operator will have both unit and integration tests, which can be run by users to verify behaviour in their intended scenarios.
    </li>
    <li>
      <strong>Trusted builds.</strong> Operators are software, which is often compiled. The integrity of the build system, and the integrity of the revision control system that drives them, is central to the provenance of the operator. A trustworthy operator system must enable trusted builds of operators as much as workloads.
    </li>
    <li>
      <strong>Signed.</strong> The trust placed in an operator means that it is important to know who produced it, and that it has not been modified. A trustworthy operator distribution system must enable verification of the provenance of any given revision at any time.
    </li>
    <li>
      <strong>Staged.</strong> Software changes are inevitable. The more widely they can be inspected and tested, and the sooner issues can be uncovered, the better. A good operator will publish not only stable changes, but upcoming releases in beta or release candidate form, and possibly a development tip, for each major version. This enables widespread testing of changes and increases the quality of stable releases.
    </li>
    <li>
      <strong>Managed.</strong> An enterprise environment must plan changes at particular times. Operator distribution mechanisms should enable fine&dash;grained control of update propagation as well as enterprise control of versions.
    </li>
  </ol>
  <p>
    As a community, these principles guide our work and make it relevant to a wider audience. The more we can improve our operators in line with these values, the more our community benefits from the entire collection of operators.
  </p>
{% endblock %}

